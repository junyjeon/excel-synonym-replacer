# Excel Synonym Replacer 개발 과정: 프롬프트 엔지니어링과 도전 과제 해결

온라인 쇼핑몰의 상품 노출 최적화는 e-커머스 사업의 핵심 요소 중 하나입니다. 검색 알고리즘은 상품명의 키워드를 기반으로 작동하기 때문에, 다양한 키워드 변형을 통해 상품 노출 빈도를 높이는 것이 중요합니다. Excel Synonym Replacer 프로젝트는 GPT 기반 프롬프트 엔지니어링으로 유의어 사전을 구축하고, 인덱스 기반 알고리즘으로 효율적인 조합을 생성하며, 직관적인 GUI로 비개발자도 쉽게 사용할 수 있는 도구입니다. 특히 대용량 데이터 처리 최적화와 유의어 품질 관리 메커니즘을 통해 수천 개 상품명을 빠르고 일관되게 변환할 수 있습니다. 이 문서에서는 프로젝트 개발 과정에서 마주한 도전 과제와 그 해결 과정을 공유합니다.

## 1. 프로젝트 배경과 요구사항

구제의류 쇼핑몰에서는 상품 정보를 `<브랜드 + 색상 + 패턴 + 소재 + 카테고리>` 형식으로 조합하여 상품명을 생성하고 있었습니다. 예를 들어 `<ADIDAS + 블랙 + 스트라이프 + 면혼방 + 빅로고카라티셔츠>` 형태입니다. 여러 온라인 마켓에 동일한 상품을 등록할 때 SEO 최적화를 위해 유사하지만 다른 키워드 조합이 필요했습니다.

**주요 요구사항**:
1. 단일 상품에 대해 여러 버전의 상품명 생성 (5~10개)
2. 브랜드, 색상, 패턴, 소재, 카테고리 등 요소별 유의어 자동 치환
3. 사용자가 치환 요소를 선택적으로 지정 가능
4. 엑셀 파일을 직접 수정하여 원본 데이터 보존
5. GUI 인터페이스로 비개발자도 사용 가능

## 2. 프롬프트 엔지니어링: 유의어 사전 구축

유의어 사전 구축은 가장 도전적인 과제 중 하나였습니다. 프로젝트의 성패를 좌우하는 핵심 요소였기 때문에 정교한 프롬프트 설계가 필요했습니다.

### 2.1 프롬프트 디자인 원칙

`synonym_extract.py` 파일에서 카테고리별로 특화된 프롬프트를 설계했습니다. 프롬프트 설계 시 다음 원칙을 적용했습니다:

1. **명확한 지시와 예시**: GPT에게 정확히 무엇을 원하는지 명시
2. **출력 형식 통일**: 콤마(,)로 구분된 단순한 텍스트 형식
3. **도메인 특화 규칙**: 각 카테고리별 특수 규칙 추가
4. **중복 방지 및 관련성 유지**: 너무 다른 유의어는 제외

### 2.2 카테고리별 프롬프트 최적화

**색상 프롬프트**:
```python
f"""'{word}' 색상의 유의어 3개만 콤마(,)로 구분해서 작성해줘
규칙:
1) 명도/채도가 다른 색상은 제외 (예: 블루≠스카이블루≠네이비)
2) 번호나 설명 없이 단어만 작성
3) 출력 형식은 '유의어1,유의어2,유의어3'를 지켜줘

예시)
입력: 검정
출력: 흑색, 블랙, 검정색"""
```

위 프롬프트는 처음에는 단순히 유의어를 요청하는 형태였으나, 실험 과정에서 다음 문제점들이 발견되었습니다:

1. **무관한 색상 생성**: 검정 → 회색, 감색 등 명확히 다른 색상 반환
2. **형식 불일치**: 설명이나 번호가 포함된 응답
3. **일관성 부족**: 응답마다 유의어 수와 형식이 달라짐

이런 문제를 해결하기 위해 프롬프트에 구체적인 규칙과 예시를 추가했습니다. 특히 "명도/채도가 다른 색상은 제외"라는 규칙을 통해 명확히 구분되는 색상이 유의어로 제안되는 문제를 해결했습니다.

**브랜드 프롬프트**:
```python
f"""'{word}' 브랜드의 한글과 영문 실제 브랜드 표기를 알려줘.
규칙:
1) 한글로 입력된 브랜드는 공식 영문 표기
2) 영문으로 입력된 브랜드는 공식 한글 표기

예시:
ADIDAS → ADIDAS, 아디다스
랩 → 랩, LAB
아미 → 아미, ARMY"""
```

브랜드의 경우 다른 카테고리와 달리 언어 전환이 중요했습니다. 한글로 된 브랜드명은 영문으로, 영문 브랜드명은 한글로 변환하는 요구사항이 있었기 때문에 프롬프트를 이에 맞게 특화시켰습니다.

### 2.3 토큰 최적화와 비용 절감

GPT-4는 성능이 뛰어나지만 비용이 높기 때문에, 토큰 사용을 최적화하는 방법을 고려했습니다:

1. **프롬프트 압축**: 불필요한 설명 제거, 간결한 예시 사용
2. **적은 수의 유의어 요청**: 3개로 제한하여 응답 길이 최소화
3. **경량 모델 사용**: 최종적으로 `gpt-4o-mini` 모델 선택
4. **중복 처리 회피**: 이미 처리된 단어는 건너뛰기

```python
if skip_existing:
    # 기존 데이터에서 원본단어 목록 추출
    existing_words = set()
    # ... 중략 ...
    # 기존에 없는 단어만 필터링
    unique_values = [v for v in unique_values if v not in existing_words]
```

## 3. 데이터 모델링과 조합 알고리즘

유의어 치환은 단순히 단어를 바꾸는 것이 아니라, 다양한 조합을 생성하는 복잡한 작업입니다. 효율적인 데이터 모델과 알고리즘 설계가 필요했습니다.

### 3.1 유의어 사전 구조

```python
# 유의어 사전 기본 구조
{
    "브랜드": {"나이키": ["NIKE", "나이키코리아"], ...},
    "색상": {"검정": ["블랙", "흑색", "차콜블랙"], ...},
    "패턴": {"스트라이프": ["줄무늬", "라인패턴", "스트라입"], ...},
    "소재": {"면혼방": ["코튼믹스", "면혼합", "코튼블렌드"], ...},
    "카테고리": {"맨투맨": ["스웨트셔츠", "기모맨투맨", "트레이닝"], ...}
}
```

이 구조는 카테고리별로 원본 단어를 키로, 유의어 리스트를 값으로 가지는 중첩 딕셔너리 형태입니다. 이 구조를 통해 O(1) 시간 복잡도로 유의어 검색이 가능합니다.

### 3.2 조합 알고리즘 설계

초기에는 모든 가능한 조합을 생성하는 방식을 고려했으나, 5개 카테고리에 각 3개 유의어가 있을 경우 3^5 = 243개의 조합이 생성되는 문제가 있었습니다. 사용자가 필요로 하는 조합은 보통 5-10개 정도이기 때문에, 인덱스 기반의 조합 알고리즘을 설계했습니다:

```python
def calculate_version_indices(ordered_lists, version_idx):
    """버전 인덱스에 따른 조합 계산"""
    # 각 리스트의 길이 계산
    list_lengths = [len(lst) for lst in ordered_lists]
    
    # 총 가능한 조합 수 계산
    total_combinations = 1
    for length in list_lengths:
        total_combinations *= length
    
    # 버전 인덱스가 조합 수를 초과하면 랩어라운드
    if version_idx >= total_combinations:
        version_idx = version_idx % total_combinations
    
    # 각 리스트에서 어떤 항목을 선택할지 계산
    indices = []
    remaining = version_idx
    
    for length in reversed(list_lengths):
        idx = remaining % length
        indices.insert(0, idx)
        remaining //= length
    
    return indices, total_combinations
```

이 알고리즘을 통해 version_idx에 따라 고유한 조합을 생성할 수 있었습니다. 예를 들어 version_idx=0은 모든 리스트의 첫 번째 항목, version_idx=1은 마지막 리스트의 두 번째 항목과 나머지 리스트의 첫 번째 항목을 선택하는 방식입니다.

## 4. GUI 개발과 사용자 경험 최적화

PySide6 (Qt for Python)을 사용하여 GUI를 개발했습니다. 비개발자도 쉽게 사용할 수 있도록 직관적인 인터페이스 설계에 중점을 두었습니다.

### 4.1 사용자 피드백 반영

실제 사용자 피드백을 통해 다음과 같은 기능을 추가했습니다:

1. **전체 선택 버튼**: 대량의 데이터를 한 번에 처리할 수 있는 기능
   ```python
   self.btn_select_all = QPushButton("전체 선택")
   self.btn_select_all.clicked.connect(self.select_all_rows)
   ```

2. **진행 상황 표시**: 대량 데이터 처리 시 진행 상황을 시각화
   ```python
   progress_dialog = QProgressDialog("상품명 생성 중...", "취소", 0, len(selected_rows), self)
   progress_dialog.setWindowModality(Qt.WindowModal)
   ```

3. **설정 저장/로드**: 사용자 설정을 JSON으로 저장하여 다음 실행 시 복원
   ```python
   def saveSettings(self):
       """사용자 설정 저장"""
       settings = {
           'last_directory': self.last_directory,
           'checkboxes': {k: v.isChecked() for k, v in self.checkbox_mapping.items()},
           'version': self.spin_version.value(),
           'overwrite': self.chk_overwrite.isChecked()
       }
       
       with open(self.settings_file, 'w', encoding='utf-8') as f:
           json.dump(settings, f, ensure_ascii=False, indent=2)
   ```

### 4.2 성능 최적화

GUI 응답성을 유지하면서 대량의 데이터를 처리하기 위한 최적화 기법을 적용했습니다:

1. **배치 처리**: 행별로 처리하되 GUI 업데이트는 주기적으로만 수행
2. **비동기 처리 고려**: 데이터 처리와 UI 업데이트를 분리
3. **메모리 관리**: 대용량 파일 처리 시 메모리 사용 최적화
   ```python
   # 워크북 리소스 관리
   try:
       # 처리 로직
   finally:
       if wb:
           wb.close()
   ```

## 5. 윈도우 7 호환성 문제 해결

고객 환경이 Windows 7인 경우가 있어, 호환성 문제를 해결해야 했습니다:

1. **Qt 버전 다운그레이드**: Windows 7 호환 버전 사용
2. **OS 감지 및 플랫폼 설정**: 운영체제에 따른 환경 설정
   ```python
   # 운영체제별 플랫폼 자동 설정
   if platform.system() == "Windows":
       os.environ["QT_QPA_PLATFORM"] = "windows"
   elif platform.system() == "Linux":
       os.environ["QT_QPA_PLATFORM"] = "xcb"
   ```
3. **라이브러리 의존성 최소화**: 필수 라이브러리만 사용

## 6. 사용자 중심 개발 과정

개발 과정에서 지속적인 사용자 피드백을 반영했습니다:

1. **반복적인 테스트**: 실제 데이터로 시스템 테스트 및 문제점 식별
2. **오류 피드백 루프**: 발견된 문제점을 즉시 해결하고 다시 테스트
3. **UI 개선**: 사용자 경험을 개선하기 위한 UI 요소 추가
4. **명확한 피드백 메시지**: 사용자가 이해하기 쉬운 오류/성공 메시지 제공

예를 들어, 초기 버전에서는 사용자가 유의어 치환 요소를 선택하고 실행하면 브랜드만 변환되는 문제가 있었습니다. 이를 해결하기 위해 데이터 모델과 변환 알고리즘을 수정하고, UI 피드백을 추가했습니다.

## 7. 유의어 치환의 품질과 한계

프로젝트 개발 과정에서 가장 중요한 교훈은 "적절한 유의어"를 정의하는 것의 어려움이었습니다. "유사하면서도 너무 다르지 않은" 단어를 찾는 것은 주관적인 판단이 필요한 영역입니다.

### 7.1 어려웠던 사례

1. **색상 유의어**: "네이비"와 "블루"는 유의어인가? 사용자에 따라 다른 해석
2. **소재 유의어**: "면혼방"과 "코튼혼합"은 의미는 같지만 검색 결과가 다름
3. **카테고리 유의어**: "맨투맨"과 "스웨트셔츠"는 유사하지만 다른 검색 의도

이러한 문제를 해결하기 위해 최종적으로는 GPT의 제안과 사용자의 수동 검증을 결합한 하이브리드 접근법을 채택했습니다. GPT가 제안한 유의어를 엑셀 시트에 저장하고, 사용자가 이를 검토하고 필요에 따라 수정할 수 있도록 했습니다.

## 8. 결론

Excel Synonym Replacer 프로젝트는 프롬프트 엔지니어링, 데이터 모델링, GUI 개발, 호환성 관리 등 다양한 영역의 기술적 도전을 포함하고 있었습니다. 특히 프롬프트 엔지니어링을 통한 유의어 사전 구축은 LLM의 능력을 실용적인 비즈니스 문제 해결에 적용한 좋은 사례입니다.

이 프로젝트를 통해 몇 가지 중요한 교훈을 얻을 수 있었습니다. 무엇보다 프롬프트 설계에서 e-커머스 도메인의 특성과 사용자 요구사항을 깊이 반영해야 한다는 점이 두드러졌습니다. 완벽하게 자동화된 시스템보다는 실용적인 반자동화 도구가 사용자에게 더 유용한 경우가 많았고, LLM의 능력과 전통적인 알고리즘을 적절히 결합하는 방식이 문제 해결에 훨씬 효과적이었습니다. 유의어 생성은 LLM에게, 조합과 처리는 최적화된 알고리즘에게 맡김으로써 각각의 장점을 극대화할 수 있었습니다.

또한 개발 과정에서 실제 사용자와의 지속적인 피드백 루프가 제품 품질 향상에 핵심이었습니다. 초기 프로토타입부터 사용자 테스트를 거친 반복적 개선 과정을 통해 실제 현장에서 발생하는 문제점들을 효과적으로 해결할 수 있었고, 이는 최종 제품의 유용성을 크게 높였습니다.

이러한 경험들은 앞으로 LLM을 활용한 실용적인 비즈니스 솔루션 개발에 있어 귀중한 밑거름이 될 것입니다. 완벽한 기술적 우아함보다는 사용자 문제 해결에 초점을 맞추되, 최신 기술의 실용적 적용 가능성을 항상 염두에 두는 균형 잡힌 접근법이 무엇보다 중요하다는 점을 확인했습니다.