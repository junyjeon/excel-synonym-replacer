# Excel Synonym Replacer: 프롬프트 엔지니어링과 도전 과제

온라인 쇼핑몰의 상품 노출 최적화는 e-커머스 사업의 핵심 요소 중 하나입니다. 검색 알고리즘은 상품명의 키워드를 기반으로 작동하기 때문에, 다양한 키워드 변형을 통해 상품 노출 빈도를 높이는 것이 중요합니다. Excel Synonym Replacer 프로젝트는 GPT 기반 프롬프트 엔지니어링으로 유의어 사전을 구축하고, 인덱스 기반 알고리즘으로 효율적인 조합을 생성하며, 직관적인 GUI로 비개발자도 쉽게 사용할 수 있는 도구입니다. 특히 대용량 데이터 처리 최적화와 유의어 품질 관리 메커니즘을 통해 수천 개 상품명을 빠르고 일관되게 변환할 수 있습니다. 이 문서에서는 프로젝트 개발 과정에서 마주한 도전 과제와 그 해결 과정을 공유합니다.

## 1. 프로젝트 배경과 요구사항

구제의류 쇼핑몰에서는 상품 정보를 `<브랜드 + 색상 + 패턴 + 소재 + 카테고리>` 형식으로 조합하여 상품명을 생성하고 있었습니다. 예를 들어 `<ADIDAS + 블랙 + 스트라이프 + 면혼방 + 빅로고카라티셔츠>` 형태입니다. 여러 온라인 마켓에 동일한 상품을 등록할 때 검색 노출을 최적화하기 위해 다양한 상품명 변형이 필요했습니다. 예를 들어, 위의 상품명은 `<아디다스 + 검정 + 줄무늬 + 코튼믹스 + 빅로고피케티>`와 같이 유의어로 변환할 수 있습니다.

클라이언트는 이러한 변환 작업을 수작업으로 진행하고 있었으며, 하루에 처리해야 하는 상품 수가 많아 효율성 문제가 발생했습니다. 이에 따라 프로세스를 자동화할 수 있는 솔루션 개발이 요청되었습니다.

**주요 요구사항**:
1. 대용량 처리: 한 번에 수천 개의 상품명 처리 가능
2. 원본 데이터 보존: 기존 엑셀 파일 구조 유지
3. 패턴 일관성: 상품명 구성 패턴 유지
4. 선택적 치환: 브랜드, 색상, 패턴 등 요소별 선택적 치환 옵션
5. 다중 버전 생성: 하나의 상품당 최대 10개 변형 생성
6. 비개발자 사용성: 직관적인 인터페이스 제공

프로젝트 초기 예상 개발 기간은 1주일이었으나, 데이터 처리와 알고리즘 최적화 과정에서 발생한 복잡성으로 인해 최종적으로 4주가 소요되었습니다.

## 2. 프롬프트 엔지니어링: 유의어 사전

유의어 사전 구축은 프로젝트 성패를 좌우하는 핵심 과제였습니다. 초기에는 WordNet과 같은 기존 언어 데이터베이스 활용을 고려했으나, e-커머스 분야의 특수 용어와 브랜드명을 포함하지 않는 한계가 있었습니다. 이에 따라 GPT API를 활용한 유의어 생성 방식을 채택했습니다.

### 2.1 프롬프트 설계

초기 프롬프트는 단순히 유의어를 요청하는 형태였습니다:

```python
f"'{word}'의 유의어를 알려주세요"
```

그러나 이 접근법은 다음과 같은 문제점을 드러냈습니다:
- 불필요한 설명과 번호 매김이 포함된 응답
- 통일되지 않은 응답 형식
- 과도한 유의어 생성으로 인한 비용 증가
- 도메인 특수성을 반영하지 못하는 유의어

이러한 문제를 해결하기 위해 카테고리별로 특화된 프롬프트를 개발했습니다. 색상 카테고리의 경우 다음과 같이 개선했습니다:

```python
f"""'{word}' 색상의 유의어 3개만 콤마(,)로 구분해서 작성해주세요.
규칙:
1) 명도/채도가 다른 색상은 제외 (예: 블루≠스카이블루≠네이비)
2) 번호나 설명 없이 단어만 작성
3) 출력 형식은 '유의어1,유의어2,유의어3'를 준수해주세요

예시)
입력: 검정
출력: 흑색,블랙,검정색"""
```

브랜드 카테고리는 한글-영문 전환이 중요했기 때문에 다음과 같이 설계했습니다:

```python
f"""'{word}' 브랜드의 한글과 영문 공식 표기를 알려주세요.
규칙:
1) 한글로 입력된 브랜드는 공식 영문 표기
2) 영문으로 입력된 브랜드는 공식 한글 표기

예시:
ADIDAS → ADIDAS,아디다스
랩 → 랩,LAB
아미 → 아미,ARMY"""
```

### 2.2 클라이언트용 유의어 생성 도구

클라이언트가 필요에 따라 직접 유의어 사전을 확장할 수 있도록 독립적인 유의어 생성 도구를 개발했습니다:

```python
def generate_synonyms_tool(category, input_file, output_file, api_key, model="gpt-4o-mini"):
    """클라이언트용 유의어 사전 생성 도구
    
    Args:
        category: 유의어 생성 카테고리 (브랜드, 색상, 패턴, 소재, 카테고리)
        input_file: 원본 단어 목록 파일
        output_file: 출력할 유의어 사전 파일
        api_key: OpenAI API 키
        model: 사용할 GPT 모델
    """
    # 카테고리별 프롬프트 템플릿 로드
    prompts = load_prompt_templates()
    
    # 입력 단어 로드
    words = load_words_from_file(input_file)
    
    # 예상 비용 계산 (대략적 추정)
    tokens_per_request = 150  # 요청당 평균 토큰 수
    cost_per_1k_tokens = 0.15 if "gpt-4" in model else 0.0015  # GPT-4 vs GPT-3.5
    estimated_cost = (len(words) * tokens_per_request / 1000) * cost_per_1k_tokens
    
    print(f"예상 API 비용: ${estimated_cost:.2f} (단어 {len(words)}개 기준)")
    proceed = input("진행하시겠습니까? (y/n): ")
    
    if proceed.lower() != 'y':
        print("작업이 취소되었습니다.")
        return
    
    # 유의어 생성 및 저장
    synonyms_dict = {}
    for word in words:
        synonyms = generate_synonyms_with_gpt(word, prompts[category], api_key, model)
        synonyms_dict[word] = synonyms
        
    save_synonyms_to_file(synonyms_dict, output_file)
    print(f"{len(words)}개 단어의 유의어가 {output_file}에 저장되었습니다.")
```

이 도구는 다음과 같은 이점을 제공했습니다:
- 클라이언트의 자체 유의어 사전 확장 가능
- 비용 투명성: 작업 전 예상 비용 표시
- 카테고리별 최적화된 프롬프트 자동 적용
- 엑셀 형식 호환성 유지

특히 비용 관리 측면에서, 초기 사전 구축에는 약 500개 단어에 대해 GPT-4 기반으로 약 $7.50의 비용이 발생했습니다. 이후에는 보다 경제적인 `gpt-4o-mini` 모델을 사용하여 동일한 작업을 $1.50 이하로 수행할 수 있도록 최적화했습니다.

### 2.3 토큰 최적화 및 비용 효율화

GPT-4 API 사용에 따른 비용 최적화를 위해 다음 전략을 구현했습니다:

1. 프롬프트 길이 최소화: 불필요한 설명 제거
2. 응답 크기 제한: 유의어 수를 각 단어당 3개로 제한
3. 모델 다운그레이드: 비용 효율적인 `gpt-4o-mini` 모델 채택
4. 중복 요청 방지: 이미 처리된 단어는 재요청하지 않음

```python
if skip_existing:
    existing_words = set(df.iloc[:, 0].dropna().unique())
    unique_values = [v for v in unique_values if v not in existing_words]
```

이러한 최적화를 통해 유의어 사전 구축 비용을 초기 예상 대비 약 70% 절감할 수 있었습니다.

## 3. 데이터 모델링과 조합 알고리즘

유의어 치환은 단순한 단어 교체 이상의 조합 알고리즘이 필요했습니다. 상품명의 각 요소(브랜드, 색상, 패턴, 소재, 카테고리)마다 유의어가 있고, 이들의 모든 조합을 고려하면 경우의 수가 기하급수적으로 증가합니다.

### 3.1 유의어 사전 구조

유의어 데이터는 다음과 같은 구조로 설계했습니다:

```python
# 유의어 사전 기본 구조
{
    "브랜드": {"나이키": ["NIKE", "나이키코리아"], ...},
    "색상": {"검정": ["블랙", "흑색", "차콜블랙"], ...},
    "패턴": {"스트라이프": ["줄무늬", "라인패턴", "스트라입"], ...},
    "소재": {"면혼방": ["코튼믹스", "면혼합", "코튼블렌드"], ...},
    "카테고리": {"맨투맨": ["스웨트셔츠", "기모맨투맨", "트레이닝"], ...}
}
```

이 구조는 O(1) 시간 복잡도로 유의어 검색이 가능하도록 설계되었습니다.

### 3.2 조합 알고리즘 개발

조합 알고리즘 개발 과정에서 직면한 주요 문제는 다음과 같았습니다:

1. **조합 폭발**: 5개 요소에 각 3개 유의어가 있을 경우 3^5 = 243개 조합 발생
2. **중복 방지**: 무작위 선택 시 동일 조합이 반복 생성될 가능성
3. **메모리 효율성**: 대량 데이터 처리 시 모든 조합을 사전 계산하기 어려움

초기에는 무작위 선택 방식을 시도했으나, 중복 조합 발생 문제로 인해 사용자 경험이 저하되었습니다. 두 번째 접근법으로 모든 가능한 조합을 미리 계산하는 방식을 시도했으나, 대용량 데이터 처리 시 메모리 초과 문제가 발생했습니다.

최종적으로 인덱스 기반 알고리즘을 개발하여 이 문제들을 해결했습니다:

```python
def calculate_version_indices(ordered_lists, version_idx):
    # 각 리스트의 길이 계산
    list_lengths = [len(lst) for lst in ordered_lists]
    
    # 총 가능한 조합 수 계산
    total_combinations = 1
    for length in list_lengths:
        total_combinations *= length
    
    # 인덱스가 조합 수를 초과하면 순환 처리
    if version_idx >= total_combinations:
        version_idx = version_idx % total_combinations
    
    # 각 리스트에서 선택할 항목 계산
    indices = []
    remaining = version_idx
    
    for length in reversed(list_lengths):
        idx = remaining % length
        indices.insert(0, idx)
        remaining //= length
    
    return indices, total_combinations
```

이 알고리즘은 version_idx에 따라 각 요소 리스트에서 선택할 항목을 결정함으로써 다음 이점을 제공합니다:
- 메모리 효율성: 조합을 실시간으로 계산하여 메모리 사용량 최소화
- 중복 방지: 인덱스 기반 접근으로 고유한 조합 보장
- 확장성: 요소 수와 무관하게 일정한 계산 복잡도 유지

## 4. GUI 개발과 사용자 경험 최적화

클라이언트가 비개발자임을 고려하여 직관적인 인터페이스 구현이 필수적이었습니다. PySide6(Qt for Python)을 사용하여 GUI를 개발했으며, 대용량 데이터 처리 시 응답성 유지에 중점을 두었습니다.

### 4.1 성능 최적화

초기 버전에서 300개 행을 처리할 때 UI 응답성 저하 문제가 발생했습니다. 비동기 처리 구현을 시도했으나 Qt의 스레드 모델과의 통합 과정에서 복잡성이 증가했습니다. 대안으로 배치 처리와 진행 대화상자를 조합한 접근법을 구현했습니다:

```python
progress_dialog = QProgressDialog("상품명 생성 중...", "취소", 0, len(selected_rows), self)
progress_dialog.setWindowModality(Qt.WindowModal)

for i, row_idx in enumerate(selected_rows):
    # 일정 간격으로 UI 업데이트 (과도한 업데이트 방지)
    if i % 50 == 0 or i == len(selected_rows) - 1:
        progress_dialog.setValue(i)
        QApplication.processEvents()  # UI 이벤트 처리
    
    # 행 처리 로직
```

이 접근법은 다음과 같은 성능 개선을 가져왔습니다:
- UI 반응성 유지: 처리 중에도 사용자 상호작용 가능
- 진행 상황 가시성: 사용자에게 명확한 피드백 제공
- 취소 기능: 장시간 처리 중 중단 옵션 제공

### 4.2 사용자 피드백 기반 개선

클라이언트 피드백을 반영하여 다음 기능들을 추가했습니다:

1. **전체 선택 버튼**: 대량 데이터 일괄 처리 지원
   ```python
   self.btn_select_all = QPushButton("전체 선택")
   self.btn_select_all.clicked.connect(self.select_all_rows)
   ```

2. **설정 저장/로드**: 반복 작업 시 사용자 편의성 향상
   ```python
   def saveSettings(self):
       settings = {
           'last_directory': self.last_directory,
           'checkboxes': {k: v.isChecked() for k, v in self.checkbox_mapping.items()},
           'version': self.spin_version.value(),
           'overwrite': self.chk_overwrite.isChecked()
       }
       
       with open(self.settings_file, 'w', encoding='utf-8') as f:
           json.dump(settings, f, ensure_ascii=False, indent=2)
   ```

3. **미리보기 기능**: 변환 결과를 적용 전에 확인할 수 있는 기능

최종 버전에서는 2,000개 이상의 행도 원활하게 처리할 수 있는 성능을 달성했습니다.

## 5. 호환성 문제

개발 후반부에 클라이언트 환경이 Windows 7임이 확인되어 호환성 문제가 발생했습니다. 최신 Qt 버전은 Windows 7을 완전히 지원하지 않아 다음과 같은 에러가 발생했습니다:
- API 의존성 불일치: 'api-ms-win-core' 관련 파일 미지원
- 렌더링 문제: 일부 UI 요소가 정상적으로 표시되지 않음

이러한 문제를 해결하기 위해 다음 전략을 구현했습니다:

1. **Qt 버전 최적화**: Windows 7과 호환되는 버전으로 다운그레이드
2. **플랫폼 감지 및 설정 조정**: 운영체제별 최적화 설정 적용
   ```python
   if platform.system() == "Windows":
       windows_version = platform.version()
       if windows_version.startswith('6.1'):  # Windows 7
           os.environ["QT_QPA_PLATFORM"] = "windows:fontengine=freetype"
           # 기타 Windows 7 특화 설정
   ```
3. **의존성 최소화**: 필수 라이브러리만 포함하여 배포 패키지 최적화

이러한 조정을 통해 Windows 7 환경에서도 안정적으로 작동하는 애플리케이션을 제공할 수 있었습니다. 다만, 호환성 유지를 위한 조치로 인해 배포 파일 크기가 약 2배 증가하는 부수 효과가 있었습니다.

## 6. 사용자 중심 개발

개발 과정에서 사용자 경험을 최우선으로 고려했으며, 정기적인 클라이언트 피드백을 통해 지속적으로 개선했습니다. 이 과정에서 얻은 주요 인사이트는 다음과 같습니다:

1. **개발자와 사용자의 관점 차이**: 개발자가 직관적이라고 생각한 인터페이스 요소가 사용자에게는 그렇지 않을 수 있음
2. **명확한 시각적 피드백**: 모든 기능에 명확한 라벨과 설명 제공
3. **오류 처리 강화**: 사용자 친화적인 오류 메시지와 해결 방법 제시
4. **가이드 제공**: 첫 실행 시 간단한 튜토리얼 추가

특히 초기 버전에서는 사용자가 유의어 치환 요소를 선택하고 실행했을 때 예상과 다른 결과가 나와 혼란이 있었습니다. 이를 해결하기 위해 변환 알고리즘을 수정하고 미리보기 기능을 추가하여 사용자가 결과를 예측할 수 있도록 개선했습니다.

## 7. 유의어 품질 관리

프로젝트에서 가장 주관적이고 도전적인 부분은 "좋은 유의어"의 정의와 선정이었습니다. 다음과 같은 문제에 직면했습니다:

1. **유의어 범위 정의**: 특정 단어들(예: "네이비"와 "블루")을 유의어로 볼 것인지에 대한 기준
2. **도메인 특수성**: 일반적으로는 다른 의미지만 특정 도메인에서는 유사하게 사용되는 단어(예: "맨투맨"과 "스웨트셔츠")
3. **검색 최적화**: 언어적으로 유사하지만 검색 결과에 다르게 영향을 미치는 단어(예: "면혼방"과 "코튼혼합")

이러한 문제를 해결하기 위해 자동화와 수동 검증을 결합한 하이브리드 접근법을 채택했습니다:

1. GPT가 제안한 유의어를 엑셀 시트에 저장
2. 클라이언트가 유의어를 검토하고 필요에 따라 수정
3. 수정된 유의어 사전을 기반으로 알고리즘 실행

추가적으로 유의어 품질 향상을 위해 검색 인기도 데이터를 참조하여 더 효과적인 유의어를 우선 순위화하는 기능을 구현했습니다.

## 8. 결론 및 교훈

Excel Synonym Replacer 프로젝트를 통해 프롬프트 엔지니어링, 데이터 모델링, GUI 개발, 호환성 관리 등 다양한 영역의 기술적 도전을 경험했습니다. 특히 GPT를 활용한 유의어 사전 구축은 LLM의 능력을 실용적인 비즈니스 문제 해결에 적용한 유의미한 사례였습니다.

이 프로젝트를 통해 얻은 주요 교훈은 다음과 같습니다:

첫째, 프롬프트 엔지니어링에서는 도메인 지식과 사용자 요구사항을 깊이 반영하는 것이 중요합니다. e-커머스 분야의 특성을 고려한 프롬프트 설계를 통해 더 정확하고 유용한 유의어를 생성할 수 있었습니다.

둘째, 완전 자동화보다는 자동화와 수동 검증을 결합한 반자동화 접근법이 더 효과적일 수 있습니다. 특히 유의어와 같은 주관적 판단이 필요한 영역에서는 사용자의 개입과 검증이 품질을 크게 향상시켰습니다.

셋째, LLM과 전통적인 알고리즘을 적절히 결합하는 방식이 문제 해결에 효과적이었습니다. 유의어 생성은 LLM에게, 조합과 처리는 최적화된 알고리즘에게 맡김으로써 각각의 장점을 극대화할 수 있었습니다.

넷째, 사용자 피드백 기반의 반복적 개선 프로세스가 제품 품질을 크게 향상시켰습니다. 초기 프로토타입부터 정기적인 사용자 테스트를 통해 실제 환경에서 발생하는 문제점을 효과적으로 식별하고 해결할 수 있었습니다.

이러한 경험은 향후 LLM을 활용한 비즈니스 솔루션 개발에 있어 귀중한 참고자료가 될 것입니다. 기술적 정교함과 사용자 중심 접근법의 균형을 유지하는 것이 실용적인 AI 솔루션 개발의 핵심임을 확인할 수 있었습니다.